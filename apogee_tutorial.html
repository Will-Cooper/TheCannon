

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tutorial with APOGEE DR10 Spectra &mdash; TheCannon 0.5.6 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="TheCannon 0.5.6 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> TheCannon
          

          
          </a>

          
            
            
              <div class="version">
                0.5.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Reference/API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">TheCannon</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Tutorial with APOGEE DR10 Spectra</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/apogee_tutorial.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tutorial-with-apogee-dr10-spectra">
<span id="apogee-tutorial"></span><h1>Tutorial with APOGEE DR10 Spectra<a class="headerlink" href="#tutorial-with-apogee-dr10-spectra" title="Permalink to this headline">Â¶</a></h1>
<p>In this example, we&#8217;re going to use spectra and labels from the 10th
APOGEE data release (DR10).
You will need to download the file
<code class="docutils literal"><span class="pre">example_DR10.tar.gz</span></code> by clicking
<a class="reference download internal" href="_downloads/example_DR10.tar.gz"><code class="xref download docutils literal"><span class="pre">here</span></code></a>
and unzip it using the command</p>
<blockquote>
<div>$ tar -zxvf example_DR10.tar.gz</div></blockquote>
<p>Inside the folder <code class="docutils literal"><span class="pre">example_DR10</span></code> you will see the following:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Data</span></code>: a folder with .fits data files (spectra)</li>
<li><code class="docutils literal"><span class="pre">reference_labels.csv</span></code>:
a table with reference label values to use in the training step</li>
</ul>
<p>Before the data can be run through <em>The Cannon</em>, it must be prepared
according to the specifications laid out in the &#8220;Requirements for Input&#8221;
section. One of the requirements is for data to be normalized
in a SNR-independent way. <code class="docutils literal"><span class="pre">TheCannon</span></code> package does have built-in
options for performing the normalization, and we illustrate that here.</p>
<p>For your own project, you would write your own code to read in the data.
For this tutorial, we provide the module <code class="docutils literal"><span class="pre">apogee.py</span></code>
so that you don&#8217;t have to figure out how to access all of the relevant
information from the .fits files.</p>
<p>First, import the necessary Python packages:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<p>Now, get the data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TheCannon</span> <span class="kn">import</span> <span class="n">apogee</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_ID</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">tr_flux</span><span class="p">,</span> <span class="n">tr_ivar</span> <span class="o">=</span> <span class="n">apogee</span><span class="o">.</span><span class="n">load_spectra</span><span class="p">(</span><span class="s2">&quot;example_DR10/Data&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_label</span> <span class="o">=</span> <span class="n">apogee</span><span class="o">.</span><span class="n">load_labels</span><span class="p">(</span><span class="s2">&quot;example_DR10/reference_labels.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Print each of the arrays to inspect the contents.
<code class="docutils literal"><span class="pre">tr_ID</span></code> is an array of IDs (unique identifiers) for all of the stars.
<code class="docutils literal"><span class="pre">wl</span></code> is the array of wavelength values.
<code class="docutils literal"><span class="pre">tr_flux</span></code> is the 2-D array of flux values (spectra for all the objects).
<code class="docutils literal"><span class="pre">tr_ivar</span></code> is the inverse variances corresponding to <code class="docutils literal"><span class="pre">tr_flux</span></code>.
<code class="docutils literal"><span class="pre">tr_label</span></code> has all of the reference labels for the training step.</p>
<p>Check to make sure that there are 548 spectra with 8575 pixels each,
and 3 labels:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tr_ID</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">wl</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tr_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tr_label</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, plot the spectrum for the object with ID &#8216;2M21332216-0048247&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tr_ID</span><span class="o">==</span><span class="s1">&#39;2M21332216-0048247&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flux</span> <span class="o">=</span> <span class="n">tr_flux</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Clearly, some of the pixels have bad values: the flux is 0.
Those should have zero inverse variances.
Let&#8217;s plot the spectrum only with pixels that are good
(that is, inverse variance &gt; 0):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ivar</span> <span class="o">=</span> <span class="n">tr_ivar</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">choose</span> <span class="o">=</span> <span class="n">ivar</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">[</span><span class="n">choose</span><span class="p">],</span> <span class="n">flux</span><span class="p">[</span><span class="n">choose</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>For simplicity, we set the test set is set as equal to the training set, so that
<code class="docutils literal"><span class="pre">TheCannon</span></code> is simply re-determining labels for the reference objects. In
practice, the test IDs, fluxes, and inverse variances would be read in
separately.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_ID</span> <span class="o">=</span> <span class="n">tr_ID</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_flux</span> <span class="o">=</span> <span class="n">tr_flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_ivar</span> <span class="o">=</span> <span class="n">tr_ivar</span>
</pre></div>
</div>
<p>Now, all the input data has been packaged properly, and we can begin running
<code class="docutils literal"><span class="pre">TheCannon.</span></code></p>
<p>The first step is to initialize a <code class="docutils literal"><span class="pre">Dataset</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TheCannon</span> <span class="kn">import</span> <span class="n">dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span><span class="n">wl</span><span class="p">,</span> <span class="n">tr_ID</span><span class="p">,</span> <span class="n">tr_flux</span><span class="p">,</span> <span class="n">tr_ivar</span><span class="p">,</span> <span class="n">tr_label</span><span class="p">,</span> <span class="n">test_ID</span><span class="p">,</span> <span class="n">test_flux</span><span class="p">,</span> <span class="n">test_ivar</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">TheCannon</span></code> has a number of optional diagnostic plots built-in, to help the
user visualize the results. Some of these plots require knowing the names
of the labels. If the user wants to produce these diagnostic plots, he or
she must specify the label names in LaTeX format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">set_label_names</span><span class="p">([</span><span class="s1">&#39;T_{eff}&#39;</span><span class="p">,</span> <span class="s1">&#39;\log g&#39;</span><span class="p">,</span> <span class="s1">&#39;[Fe/H]&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>At this stage, two diagnotic plots can already be produced,
one with the distribution
of SNR in the training and test set (in practice, the training set
should consist of higher SNR spectra than the test set)
and the other using <code class="docutils literal"><span class="pre">triangle.py</span></code> to plot
every label&#8217;s set of training values against every other.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_SNR</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/SNRdist.png" src="_images/SNRdist.png" />
<p>We can also plot the reference labels against each other:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_ref_labels</span><span class="p">()</span>
</pre></div>
</div>
<p>That figure should look like this:</p>
<img alt="_images/ref_labels_triangle.png" src="_images/ref_labels_triangle.png" />
<p>Again, <code class="docutils literal"><span class="pre">TheCannon</span></code> requires incoming spectra to be continuum normalized
in a way that is independent of signal to noise. If the data does not satisfy
this criteria already, the user can use the continuum identification and
normalization functions built into <code class="docutils literal"><span class="pre">TheCannon</span></code>.</p>
<p>First, continuum pixels are identified from a pseudo-continuum normalized
version of the training set spectra. Pseudo-continuum normalization is
performed using a running quantile. In this case, the
window size for calculating the median is set to 50 Angstroms and the quantile
level is set to 90%. APOGEE spectra come in three chunks, and we want to
perform continuum normalization for each chunk separately. For <code class="docutils literal"><span class="pre">TheCannon</span></code>
to treat spectra in chunks, the <code class="docutils literal"><span class="pre">ranges</span></code> attribute must be set:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">371</span><span class="p">,</span><span class="mi">3192</span><span class="p">],</span> <span class="p">[</span><span class="mi">3697</span><span class="p">,</span><span class="mi">5997</span><span class="p">],</span> <span class="p">[</span><span class="mi">6461</span><span class="p">,</span><span class="mi">8255</span><span class="p">]]</span>
</pre></div>
</div>
<p>Even if a spectral dataset do not consist of chunks separated by gaps, one can
imagine other reasons for wanting to treat a spectrum as though it had gaps:
for example, if different regions of a spectrum behave very differently, it
might be sensible to treat each of them separately in continuum normalization.
The user should make sure to examine the results of continuum normalization,
for example plotting fifty sample continuum fits and continuum normalized
spectra.</p>
<p>Pseudo continuum normalization can then be performed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pseudo_tr_flux</span><span class="p">,</span> <span class="n">pseudo_tr_ivar</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">continuum_normalize_training_q</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span><span class="n">q</span><span class="o">=</span><span class="mf">0.90</span><span class="p">,</span> <span class="n">delta_lambda</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>Once the pseudo continuum has been calculated, a continuum mask is created:
True values correspond to pixels that are continuum, False to those that are
not. &#8220;True&#8221; continuum pixels are identified using a median and variance flux
cut across the training objects: in other words, continuum pixels are those
that consistently have values close to 1 in all of the training spectra. The
user specifies what fraction of pixels to identify as continuum, and the
flux and variance cuts are determined appropriately. If the <code class="docutils literal"><span class="pre">ds.ranges</span></code>
attribute is set, then continuum pixels are identified separately for each
region (in this case, three regions). This enables the user to control how
evenly spread the pixels are.</p>
<p>In this case, we choose 7% of the pixels in the spectrum as continuum, but the
best value should be determined through experimentation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">contmask</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">make_contmask</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span><span class="n">pseudo_tr_flux</span><span class="p">,</span> <span class="n">pseudo_tr_ivar</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="mf">0.07</span><span class="p">)</span>
</pre></div>
</div>
<p>At this stage, the user should plot spectra overlaid with the identified
continuum pixels to ensure that they look reasonable and that they roughly
evenly cover the spectrum. Large gaps in continuum pixels could result in
poor continuum normalization in those regions. If the continuum pixels
do not look evenly sampled enough, the range can be changed and the process
repeated. For this example, we change it as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">371</span><span class="p">,</span><span class="mi">3192</span><span class="p">],</span> <span class="p">[</span><span class="mi">3697</span><span class="p">,</span><span class="mi">5500</span><span class="p">],</span> <span class="p">[</span><span class="mi">5500</span><span class="p">,</span><span class="mi">5997</span><span class="p">],</span> <span class="p">[</span><span class="mi">6461</span><span class="p">,</span><span class="mi">8255</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contmask</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">make_contmask</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span><span class="n">pseudo_tr_flux</span><span class="p">,</span> <span class="n">pseudo_tr_ivar</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="mf">0.07</span><span class="p">)</span>
</pre></div>
</div>
<p>Once a satisfactory set of continuum pixels has been identified, the dataset&#8217;s
continuum mask attribute is set as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">set_continuum</span><span class="p">(</span><span class="n">contmask</span><span class="p">)</span>
</pre></div>
</div>
<p>Once the dataset has a continuum mask, the continuum is fit for using either
a sinusoid or chebyshev function. In this case, we use a sinusoid; the user
can specify the desired order. Again, this is 3 for this simple illustration,
but should be determined through experimentation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cont</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">fit_continuum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;sinusoid&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once a satisfactory continuum has been fit, the normalized training and test
spectra can be calculated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">norm_tr_flux</span><span class="p">,</span> <span class="n">norm_tr_ivar</span><span class="p">,</span> <span class="n">norm_test_flux</span><span class="p">,</span> <span class="n">norm_test_ivar</span> <span class="o">=</span> \
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">continuum_normalize</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span>
</pre></div>
</div>
<p>If these normalized spectra look acceptable, then they can be set:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">tr_flux</span> <span class="o">=</span> <span class="n">norm_tr_flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">tr_ivar</span> <span class="o">=</span> <span class="n">norm_tr_ivar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">test_flux</span> <span class="o">=</span> <span class="n">norm_test_flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">test_ivar</span> <span class="o">=</span> <span class="n">norm_test_ivar</span>
</pre></div>
</div>
<p>Now, the data munging is over and we&#8217;re ready to run <code class="docutils literal"><span class="pre">TheCannon</span></code>!</p>
<p>For the training step (fitting for the spectral model) all the user needs to
specify is the desired polynomial order of the spectral model.
In this case, we use a quadratic model: order = 2</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TheCannon</span> <span class="kn">import</span> <span class="n">model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">md</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CannonModel</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">md</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p>At this stage, more optional diagnostic plots can be produced to examine
the spectral model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">md</span><span class="o">.</span><span class="n">diagnostics_contpix</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">md</span><span class="o">.</span><span class="n">diagnostics_leading_coeffs</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">md</span><span class="o">.</span><span class="n">diagnostics_plot_chisq</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p>The first is a series of plots showing the full baseline (first-order) model
spectrum with continuum pixels overplotted.</p>
<img alt="_images/contpix.gif" src="_images/contpix.gif" />
<p>The second is a plot of the leading coefficients and scatter of the model
as a function of wavelength</p>
<img alt="_images/leading_coeffs.png" src="_images/leading_coeffs.png" />
<p>The third is a histogram of the reduced chi squareds of the model fit.</p>
<img alt="_images/modelfit_chisqs.png" src="_images/modelfit_chisqs.png" />
<p>If the model fitting worked, then we can proceed to the test step. This
command automatically updates the dataset with the fitted-for test labels,
and returns the corresponding covariance matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">label_errs</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">infer_labels</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p>You can access the new labels as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_labels</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">test_label_vals</span>
</pre></div>
</div>
<p>A set of diagnostic output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_test_step_flagstars</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_survey_labels</span><span class="p">()</span>
</pre></div>
</div>
<p>The first generates one text file for each label, called <code class="docutils literal"><span class="pre">flagged_stars.txt</span></code>.
The second generates a triangle plot of the survey (Cannon) labels,
shown below.</p>
<img alt="_images/survey_labels_triangle.png" src="_images/survey_labels_triangle.png" />
<p>If the test set is simply equivalent to the training set,
as in this example, then one final diagnostic plot can be produced:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_1to1</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/1to1_label_0.png" src="_images/1to1_label_0.png" />
<img alt="_images/1to1_label_1.png" src="_images/1to1_label_1.png" />
<img alt="_images/1to1_label_2.png" src="_images/1to1_label_2.png" />
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Anna Ho.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.5.6',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>