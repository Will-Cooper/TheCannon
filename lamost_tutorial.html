

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tutorial with LAMOST DR2 Spectra &mdash; TheCannon 0.5.6 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="TheCannon 0.5.6 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> TheCannon
          

          
          </a>

          
            
            
              <div class="version">
                0.5.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_requirements.html">Requirements for Input</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Reference/API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">TheCannon</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Tutorial with LAMOST DR2 Spectra</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/lamost_tutorial.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tutorial-with-lamost-dr2-spectra">
<span id="lamost-tutorial"></span><h1>Tutorial with LAMOST DR2 Spectra<a class="headerlink" href="#tutorial-with-lamost-dr2-spectra" title="Permalink to this headline">Â¶</a></h1>
<p>In this tutorial, we&#8217;re going to use <em>The Cannon</em>
to transfer a system of labels from APOGEE to LAMOST.
More specifically, we&#8217;re going to model LAMOST spectra as a function of
four labels from APOGEE DR12 (the 12th data release):
effective temperature T_eff, surface gravity logg, metallicity [Fe/H],
and alpha enhancement [alpha/Fe].
To fit this model, we will use a <em>reference set</em>,
a set of stars observed in common between APOGEE
and LAMOST.
We will then be able to use this model
to determine these four APOGEE-scale labels
from any new LAMOST spectrum,
provided that the parameters of that star lie
within the range of the reference set.
For more details on this procedure,
see the accompanying paper <a class="reference external" href="http://iopscience.iop.org/article/10.3847/1538-4357/836/1/5/pdf">Ho et al. 2017</a>.</p>
<p>As described in that paper,
there are 11,057 objects measured in common between APOGEE and LAMOST.
For the purpose of this tutorial, to speed things up,
we&#8217;re only going to use the highest-SNR subset of the LAMOST spectra,
those with SNR &gt; 100. This SNR cut leaves 1387 stars.</p>
<p>The spectra for those 1387 stars can be found in the folder
<code class="docutils literal"><span class="pre">lamost_spectra</span></code>, which you can download by clicking
<a class="reference download internal" href="_downloads/lamost_spectra.zip"><code class="xref download docutils literal"><span class="pre">here</span></code></a>. You can unzip the files using
the command</p>
<blockquote>
<div>$ unzip lamost_spectra.zip</div></blockquote>
<p>Next, navigate into the <code class="docutils literal"><span class="pre">spectra</span></code> directory
and count the number of files using</p>
<blockquote>
<div>$ ls | wc -l</div></blockquote>
<p>There should be 1387 files, one for each SNR &gt; 100 spectrum.</p>
<p>Since all of these stars were observed both by APOGEE and by LAMOST,
each one has:
a spectrum measured by APOGEE,
a spectrum measured by LAMOST,
a set of parameters measured by the APOGEE pipeline using the APOGEE spectrum,
and a set of parameters measured by the LAMOST pipeline using the LAMOST spectrum.
In this tutorial, our goal is to fit a model that can, directly from a LAMOST spectrum,
measure a set of parameters consistent with those that <em>would</em> have been
measured by the APOGEE pipeline from the corresponding APOGEE spectrum.
In other words, even without an APOGEE spectrum for a star, we aim to measure
a set of parameters that is on the physical scale of APOGEE stellar labels.
Thus, this amounts to a kind of cross-calibration between the two surveys.</p>
<p>We will use 1000 of our 1387 stars to train the model
(these 1000 stars constitute our <em>reference set</em>)
then test the model on the remaining 387 objects
(these 387 stars constitutes our <em>test set</em>).
At the end, we will check our Cannon values for the
test set by comparing them to the real APOGEE DR12 values
for these 387 objects.
So, in summary: in addition to the spectra from LAMOST that we already downloaded,
we need reference labels from APOGEE DR12,</p>
<p>You can download the APOGEE labels for these 1387 objects by clicking
<a class="reference download internal" href="_downloads/lamost_labels.fits"><code class="xref download docutils literal"><span class="pre">here</span></code></a>.
Let&#8217;s use the <code class="docutils literal"><span class="pre">astropy</span></code> module to examine the contents of this file.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;lamost_labels.fits&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span>
</pre></div>
</div>
<p>You&#8217;ll see that the first column is called <code class="docutils literal"><span class="pre">LAMOST_ID</span></code>,
and the rest are <code class="docutils literal"><span class="pre">RA</span></code>, <code class="docutils literal"><span class="pre">Dec</span></code>, <code class="docutils literal"><span class="pre">APOGEE_ID</span></code>,
<code class="docutils literal"><span class="pre">TEFF</span></code>, <code class="docutils literal"><span class="pre">LOGG</span></code>, <code class="docutils literal"><span class="pre">PARAM_M_H</span></code> and <code class="docutils literal"><span class="pre">PARAM_ALPHA_M</span></code>.
All of these stars were observed by both LAMOST and APOGEE,
which is why they have a LAMOST ID as well as an APOGEE ID.
The Teff, logg, [M/H], and [alpha/M] values are taken from
APOGEE.</p>
<p>Let&#8217;s take a look at the data.</p>
<p>First, we&#8217;ll plot one spectrum.
The <code class="docutils literal"><span class="pre">load_spectra</span></code> module in <code class="docutils literal"><span class="pre">TheCannon</span></code> code
provides a way to load the data.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TheCannon.lamost</span> <span class="kn">import</span> <span class="n">load_spectra</span>
</pre></div>
</div>
<p>The filenames of the spectra correspond to the IDs in the LAMOST_ID column
described above. Let&#8217;s pick the first one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LAMOST_ID&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</pre></div>
</div>
<p>You need the <code class="docutils literal"><span class="pre">strip()</span></code> at the end to get rid of white spaces.</p>
<p>Load the spectrum by feeding the filename into the <code class="docutils literal"><span class="pre">load_spectra</span></code> function.
This function returns an array of wavelength values,
an array of corresponding flux values at each wavelength,
and an array of corresponding inverse variance values at each wavelength.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">load_spectra</span><span class="p">(</span><span class="s2">&quot;spectra/&quot;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot the spectrum, first importing <code class="docutils literal"><span class="pre">matplotlib</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Wavelength (Angstroms)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Flux&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>You can look at the spectrum either using
&gt;&gt;&gt; plt.show()</p>
<p>Or by saving the file and then opening it using whatever you usually use
to view .png files:
&gt;&gt;&gt; plt.savefig(&#8220;sample_spectrum.png&#8221;)</p>
<p>This is what it should look like:</p>
<img alt="images_lamost/sample_spec.png" src="images_lamost/sample_spec.png" />
<p>Now, get all of the files</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LAMOST_ID&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filenames_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">specdir</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">load_spectra</span><span class="p">(</span><span class="n">filenames_full</span><span class="p">)</span>
</pre></div>
</div>
<p>We&#8217;ll use the first 1000 stars as the training set.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tr_flux</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_ivar</span> <span class="o">=</span> <span class="n">ivar</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_ID</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">filenames</span><span class="o">==</span><span class="n">val</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">tr_ID</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_teff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;TEFF&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_logg</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LOGG&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_mh</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;PARAM_M_H&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_alpham</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;PARAM_ALPHA_M&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
</pre></div>
</div>
<p>Let&#8217;s look at the teff-logg diagram of the training labels,
color-coded by metallicity.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">tr_teff</span><span class="p">,</span> <span class="n">tr_logg</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">tr_mh</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">invert_xaxis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Teff&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;logg&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;M/H&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;teff_logg_training.png&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that there are very few stars at low metallicity,
so it will probably be challenging to do as good of a job
or get as precise results here.</p>
<p>Before the data can be run through <code class="docutils literal"><span class="pre">TheCannon</span></code>, it must be prepared
according to the specifications laid out in the &#8220;Requirements for Input&#8221;
section. One of the requirements is for data to be continuum normalized
in a SNR-independent way. <code class="docutils literal"><span class="pre">TheCannon</span></code> does have built-in
options for continuum normalizing spectra, and we illustrate that here.</p>
<p>Here are the steps for reading in the data. In practice, the user would
write his own code; for this example, we provide the module <code class="docutils literal"><span class="pre">apogee.py</span></code>.
The procedure for reading in spectra and training labels of course depends on
the survey, the file type, etc, and it is up to the user to package this
all appropriately before feeding it into <code class="docutils literal"><span class="pre">TheCannon</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LAMOST_ID&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filenames_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">specdir</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">load_spectra</span><span class="p">(</span><span class="n">filenames_full</span><span class="p">)</span>
</pre></div>
</div>
<p>There should be XXXX spectra with 3626 pixels each.
We&#8217;ll choose the first 1000 stars for the training set,
and use the rest for the test set.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tr_flux</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_ivar</span> <span class="o">=</span> <span class="n">ivar</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_ID</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
</pre></div>
</div>
<p>Let&#8217;s get the reference labels</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">filenames</span><span class="o">==</span><span class="n">val</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">tr_ID</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_teff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;TEFF&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_logg</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LOGG&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_mh</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;PARAM_M_H&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_alpham</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;PARAM_ALPHA_M&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
</pre></div>
</div>
<p>Take a look at the teff-logg diagram, color-coded by metallicity
&gt;&gt;&gt; plt.scatter(tr_teff, tr_logg, c=tr_mh, lw=0, s=7, cmap=&#8221;viridis&#8221;)
&gt;&gt;&gt; plt.gca().invert_xaxis()
&gt;&gt;&gt; plt.xlabel(&#8220;Teff&#8221;)
&gt;&gt;&gt; plt.ylabel(&#8220;logg&#8221;)
&gt;&gt;&gt; plt.colorbar(label=&#8221;M/H&#8221;)
&gt;&gt;&gt; plt.savefig(&#8220;teff_logg_training.png&#8221;)
&gt;&gt;&gt; plt.close()</p>
<p>Note that there are very few stars at low metallicity,
so it will probably be challenging to do as good of a job
or get as precise results here.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">wl</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tr_ID</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tr_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tr_ivar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>[num_training_objects, num_pixels]
(1339, 3626)
Fine. Not normalized yet, but we will do that later.</p>
<p>Now we need a block of training labels
[num_training_objects, num_labels]
Right now we have them separate, combine into an array of this shape:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tr_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">tr_teff</span><span class="p">,</span> <span class="n">tr_logg</span><span class="p">,</span> <span class="n">tr_mh</span><span class="p">,</span> <span class="n">tr_alpham</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that that gives us (4,1339) which is (num_labels, num_tr_obj),
So we need to take the transpose</p>
<p>Now we need to define our &#8220;test set&#8221;: a bunch of other
spectra whose labels we want to determine and don&#8217;t know yet.
Let&#8217;s use some of the other spectra in the dataset
Say, the ones with 80 &lt; SNR &lt; 100
&gt;&gt;&gt; test_ID = filenames[1000:]
&gt;&gt;&gt; test_flux = flux[1000:]
&gt;&gt;&gt; test_ivar = ivar[1000:]</p>
<p>Check the sizes
&gt;&gt;&gt; print(test_ID.shape)
&gt;&gt;&gt; print(test_flux.shape)
&gt;&gt;&gt; print(test_ivar.shape)</p>
<p>Now, all the input data has been packaged properly, and we can begin running
<code class="docutils literal"><span class="pre">TheCannon.</span></code></p>
<p>The first step is to initialize a <code class="docutils literal"><span class="pre">Dataset</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span><span class="n">wl</span><span class="p">,</span> <span class="n">tr_ID</span><span class="p">,</span> <span class="n">tr_flux</span><span class="p">,</span> <span class="n">tr_ivar</span><span class="p">,</span> <span class="n">tr_label</span><span class="p">,</span> <span class="n">test_ID</span><span class="p">,</span> <span class="n">test_flux</span><span class="p">,</span> <span class="n">test_ivar</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">TheCannon</span></code> has a number of optional diagnostic plots built-in, to help the
user visualize the results. Some of these plots require knowing the names
of the labels. If the user wants to produce these diagnostic plots, he or
she must specify the label names in LaTeX format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">set_label_names</span><span class="p">([</span><span class="s1">&#39;T_{eff}&#39;</span><span class="p">,</span> <span class="s1">&#39;\log g&#39;</span><span class="p">,</span> <span class="s1">&#39;[M/H]&#39;</span><span class="p">,</span> <span class="s1">&#39;[alpha/M]&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>At this stage, two diagnotic plots can already be produced,
one with the distribution
of SNR in the training and test set (in practice, the training set
should consist of higher SNR spectra than the test set)
and the other using <code class="docutils literal"><span class="pre">triangle.py</span></code> to plot
every label&#8217;s set of training values against every other.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_SNR</span><span class="p">()</span>
</pre></div>
</div>
<img alt="images_lamost/SNRdist.png" src="images_lamost/SNRdist.png" />
<p>We can also plot the reference labels against each other:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_ref_labels</span><span class="p">()</span>
</pre></div>
</div>
<p>That figure should look like this:</p>
<img alt="_images/ref_labels.png" src="_images/ref_labels.png" />
<p>Again, <code class="docutils literal"><span class="pre">TheCannon</span></code> requires incoming spectra to be normalized
in a way that is independent of signal to noise. If the data does not satisfy
this criteria already, the user can use the
functions built into <code class="docutils literal"><span class="pre">TheCannon</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">continuum_normalize_gaussian_smoothing</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>Let&#8217;s take a look at a normalized spectrum.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">wl</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">tr_flux</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Wavelength (Angstroms)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Flux&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/norm_spec.png" src="_images/norm_spec.png" />
<p>Now, the data munging is over and we&#8217;re ready to run <code class="docutils literal"><span class="pre">TheCannon</span></code>!</p>
<p>For the training step (fitting for the spectral model) all the user needs to
specify is the desired polynomial order of the spectral model.
In this case, we use a quadratic model: order = 2</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CannonModel</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">useErrors</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p>At this stage, more optional diagnostic plots can be produced to examine
the spectral model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">diagnostics_leading_coeffs</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p>The second is a plot of the leading coefficients and scatter of the model
as a function of wavelength</p>
<img alt="_images/leading_coeffs1.png" src="_images/leading_coeffs1.png" />
<p>If the model fitting worked, then we can proceed to the test step. This
command automatically updates the dataset with the fitted-for test labels,
and returns the corresponding covariance matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">starting_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">tr_label</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">m</span><span class="o">.</span><span class="n">pivots</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">errs</span><span class="p">,</span> <span class="n">chisq</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">infer_labels</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">starting_guess</span><span class="p">)</span>
</pre></div>
</div>
<p>You can access the new labels as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_labels</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">test_label_vals</span>
</pre></div>
</div>
<p>A set of diagnostic output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_survey_labels</span><span class="p">()</span>
</pre></div>
</div>
<p>The second generates a triangle plot of the survey (Cannon) labels,
shown below.</p>
<img alt="_images/survey_labels.png" src="_images/survey_labels.png" />
<p>Now we can compare the &#8220;real&#8221; values to the Cannon values, for the test objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">filenames</span><span class="o">==</span><span class="n">val</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">test_ID</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_teff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;TEFF&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_logg</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LOGG&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_mh</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;PARAM_M_H&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_alpham</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;PARAM_ALPHA_M&#39;</span><span class="p">][</span><span class="n">inds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">test_teff</span><span class="p">,</span> <span class="n">test_logg</span><span class="p">,</span> <span class="n">test_mh</span><span class="p">,</span> <span class="n">test_alpham</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">tr_label</span> <span class="o">=</span> <span class="n">test_label</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">diagnostics_1to1</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/1to1_label_01.png" src="_images/1to1_label_01.png" />
<img alt="_images/1to1_label_11.png" src="_images/1to1_label_11.png" />
<img alt="_images/1to1_label_21.png" src="_images/1to1_label_21.png" />
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Anna Ho.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.5.6',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>